/* Generated by Together */

package com.dimata.harisma.utility.service.leavedp;

import java.util.Vector;
import java.util.Date;
import java.util.Calendar;
import com.dimata.system.entity.PstSystemProperty;
import com.dimata.harisma.entity.service.*;
import com.dimata.harisma.entity.masterdata.PstLeavePeriod;
import com.dimata.harisma.entity.masterdata.LeavePeriod;
import com.dimata.harisma.entity.leave.I_Leave;
import com.dimata.harisma.entity.log.PstSysLogger;
import com.dimata.system.entity.PstSystemProperty;
import com.dimata.util.Formater;


public class AutomaticStockAlUpdater implements Runnable { 

    int i = 0;
    //update by satrya 2013-02-25
    private Date startDate=null;
     private boolean running = false;
    public AutomaticStockAlUpdater() {
    }

    public void run() 
    {                        
        try 
        {
            this.setRunning(true);
            long oidleave = 0;
            System.out.println(".:: AutomaticStockAlUpdater service started ... !!!");            
            ServiceAlStock stockAlServices = new ServiceAlStock();            
            I_Leave leaveConfig = null;
                try {
                    leaveConfig = (I_Leave) (Class.forName(PstSystemProperty.getValueByName("LEAVE_CONFIG")).newInstance());
                } catch (Exception e) {
                    System.out.println("Exception : " + e.getMessage());
                    System.out.println("Please contact your system administration to setup system property: LEAVE_CONFIG ");
                }
            
            // added on 20040928
           // boolean firstProcess = true;
            ServiceConfiguration svcConf = PstServiceConfiguration.getSvcConfigurationByType(PstServiceConfiguration.SERVICE_TYPE_LEAVE);
            int sleepTime = getSleepTime(new Date(), svcConf!=null ?svcConf.getStartTime(): new Date());                                       
            if(sleepTime < 5000)
                        sleepTime = 5000;
            System.out.println(".:: First process start running lateness services, thread now sleep/pause for "+(sleepTime / (60 * 1000))+" minutes ("+sleepTime+" ms)");
           Date StartDate = getStartDate();
           
            while (this.isRunning()) 
                //while (ServiceAlStock.isRunning()) 
            {     
              
                Date EndDate = new Date();
                // added on 20040928
               /* if(firstProcess)
                {
                    // sleeping time for first process                    
                    Thread.sleep(sleepTime);                                                                                   
                    firstProcess = false;                                       
                }                                
                else*/
                {
                    // proses perolehan dan expired AL
                    /*System.out.println("proses owning & expired AL dengan date : " + new Date());
                    stockAlServices.processAlStock();                    */
                    
                    try{ // add by Kartika 2012-01-23
                      String outL ="";
                      long diffStartToFinish = (EndDate.getTime() - StartDate.getTime());
                           int itDate = Integer.parseInt(String.valueOf(diffStartToFinish / 86400000));
                             for(int idxDt=0; idxDt<=itDate;idxDt++){
                                
                                Date selectedDate = new Date(StartDate.getTime() + idxDt * 1000L * 60 * 60 * 24);
                                 System.out.println("hasil date AL "+StartDate + idxDt);
                                 outL= outL + leaveConfig.setAutoALEntitle(selectedDate); 
                       }
                       
                        //update by satrya 2013-02-25
                        // String outL= leaveConfig.setAutoALEntitle(); 
                        if(outL!=null && outL.length()>0){
                            com.dimata.harisma.entity.log.SysLogger sysLog = new com.dimata.harisma.entity.log.SysLogger();
                            sysLog.setLogCategory(PstSysLogger.LOG_LEVEL_INFO);                
                            sysLog.setLogDate(new Date());
                            sysLog.setLogNote(outL);
                            sysLog.setLogSysMode("Service Presence : Automatic Annual Leave Entile ");
                            com.dimata.harisma.entity.log.PstSysLogger.insertExc(sysLog);
                            //com.dimata.harisma.entity.log.PstSysLogger.insertExc(sysLog);
                            //hanya untuk test
                          //  System.out.println("Date"+ Formater.formatDate(getStartDate(), "dd MMMM yyyy - HH:mm:ss"));
                        }
                        /*else{
                            //jika outL sudah abis maka matikan treadnya
                            this.setRunning(false);
                        }*/
                    if (!this.isRunning())
                    {
                        this.setRunning(false);
                        break;
                        
                    }
                    }catch(Exception exc){
                        System.out.println(exc);
                          this.setRunning(false);
                    }

                

                    // sleeping time for next process                    
                    //ServiceConfiguration svcConf = PstServiceConfiguration.getSvcConfigurationByType(PstServiceConfiguration.SERVICE_TYPE_LEAVE);                        

                    // convert periode (in minutes) to miliseconds (multiply by 60 * 1000)
                    //int sleepTime = svcConf.getPeriode() * 60 * 1000;                        
                    //System.out.println(".:: proses generate and expired AL finished, thread now sleep/pause for "+svcConf.getPeriode()+" minutes ("+sleepTime+" ms)");
                                        // sleeping time for next process                    
                    svcConf = PstServiceConfiguration.getSvcConfigurationByType(PstServiceConfiguration.SERVICE_TYPE_LEAVE);                        
                    // convert periode (in minutes) to miliseconds (multiply by 60 * 1000)
                    sleepTime = (svcConf!=null ? svcConf.getPeriode():0) * 60 * 1000;                        
                    //System.out.println(".:: proses generate LL's finished, thread now sleep/pause for "+svcConf.getPeriode()+" minutes ("+sleepTime+" ms)");
                    
                   //System.out.println("Date start:"+Formater.formatDate(StartDate, "dd-MM-yyyy HH:mm:ss"));
                   Date tmpStartDate = new Date();
                    tmpStartDate.setHours(0);
                    tmpStartDate.setMinutes(0);
                    tmpStartDate.setSeconds(0);
              //artinya jika user menjalankan tgl 29 juni 2013 setelah berganti hari atau besoknya tgl 30 juni agar di ganti
                    StartDate = tmpStartDate;
                    Thread.sleep(sleepTime);                                            
                   // System.out.println("Date perubahan:"+Formater.formatDate(StartDate, "dd-MM-yyyy HH:mm:ss"));
                }
            }
        }
        catch (Exception e) 
        {
            System.out.println(">>> Exception on AutomaticStockAlUpdater service :((");
        }
    }
    
    /**
     * @param start
     * @param end
     * @return
     */    
    public int getSleepTime(Date start, Date end){  
        Date s = new Date();
        Date e = new Date();
        
        s.setHours(start.getHours());
        s.setMinutes(start.getMinutes());
        s.setSeconds(start.getSeconds());
        
        e.setHours(end.getHours());
        e.setMinutes(end.getMinutes());
        e.setSeconds(end.getSeconds());
        
        if(end.getHours() < start.getHours())
        {
            int dtEnd = e.getDate();
            e.setDate(dtEnd+1);
        }        
        
        long st = s.getTime();
        long en = e.getTime();
        long rs = en - st;
        if(rs < 0)
        {
            rs = 0;
        }
        
        return (new Long(rs)).intValue();
    }    

    /**
     * @return the startDate
     */
    public Date getStartDate() {
        return startDate;
    }

    /**
     * @param startDate the startDate to set
     */
    public void setStartDate(Date startDate) {
        this.startDate = startDate;
    }

    /**
     * @return the running
     */
    public boolean isRunning() {
        return running;
    }

    /**
     * @param running the running to set
     */
    public void setRunning(boolean running) {
        this.running = running;
    }
    
}
