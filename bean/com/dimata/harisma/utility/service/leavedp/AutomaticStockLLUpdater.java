/* Generated by Together */

package com.dimata.harisma.utility.service.leavedp;

import java.util.Vector;
import java.util.Date;
import com.dimata.harisma.entity.employee.PstEmployee;
import com.dimata.harisma.entity.leave.I_Leave;
import com.dimata.harisma.entity.service.*;
import com.dimata.system.entity.PstSystemProperty;
import com.dimata.util.Formater;


public class AutomaticStockLLUpdater implements Runnable {
    private boolean running = false;
        private Date startDate=null;
    public AutomaticStockLLUpdater() 
    {
    }

    public void run()
    {
        try 
        {
            System.out.println(".:: AutomaticStockLLUpdater service started ... !!!");
            ServiceConfiguration svcConf = PstServiceConfiguration.getSvcConfigurationByType(PstServiceConfiguration.SERVICE_TYPE_LEAVE);
            int sleepTime = getSleepTime(new Date(), svcConf!=null ?svcConf.getStartTime(): new Date());                                       
            if(sleepTime < 5000)
             sleepTime = 5000;
            System.out.println(".:: First process start running LL updater services, thread now sleep/pause for "+(sleepTime / (60 * 1000))+" minutes ("+sleepTime+" ms)");

            // added on 20040928
            boolean firstProcess = true;
              this.setRunning(true);
              Date StartDate = getStartDate();
            I_Leave leave = null;
            /* Instantiate configuration class */
            try {
                leave = (I_Leave)(Class.forName(PstSystemProperty.getValueByName("LEAVE_CONFIG")).newInstance());
            }
            catch(Exception e) {
                System.out.println("Error on loading leave config " + e.getMessage());
                return;
            }
            while (this.isRunning())
                //update by satrya 2013-06-29
                // while (ServiceLLStock.running) 
            {
                // added on 20040928
                Date EndDate = new Date();
                /*if(firstProcess)
                {
                    // sleeping time for first process                    
                    ServiceConfiguration svcConf = PstServiceConfiguration.getSvcConfigurationByType(PstServiceConfiguration.SERVICE_TYPE_LEAVE);
                    int sleepTime = getSleepTime(new Date(), svcConf!=null ? svcConf.getStartTime(): new Date());                                       
                    System.out.println(".:: First process start running LL updater services, thread now sleep/pause for "+(sleepTime / (60 * 1000))+" minutes ("+sleepTime+" ms)");
                    Thread.sleep(sleepTime);                                                               
                      
                    firstProcess = false;                                       
                }*/                

                //else
                //{ 
                //pengecekan menggunakan apakah akan menggunakan LL
               // int[] intervalLL = leave==null? null:leave.getIntervalLLinMonths();
               // if(leave!=null && intervalLL!=null && ((intervalLL[leave.INTERVAL_LL_5_YEAR]/12)!=0 || (intervalLL[leave.INTERVAL_LL_5_YEAR]/12)!=0)){
                     long diffStartToFinish = (EndDate.getTime() - StartDate.getTime());
                    int itDate = Integer.parseInt(String.valueOf(diffStartToFinish / 86400000));
                      for(int idxDt=0; idxDt<=itDate;idxDt++){
                           
                         Date selectedDate = new Date(StartDate.getTime() + idxDt * 1000L * 60 * 60 * 24);
                         //ServiceLLStock.processLLStockTread(selectedDate);
                          System.out.println("hasil date LL "+selectedDate + idxDt);
                         leave.setAutoLLEntitle(selectedDate, leave);
                      }
               // }
                    
                    //ServiceLLStock.processLLStock();

                    if (!this.isRunning())
                        // update by satrya 2013-06-29
                        //  if (!ServiceLLStock.running)
                    {
                        this.setRunning(false);
                        break;
                        
                    }

                    // sleeping time for next process                    
                    svcConf = PstServiceConfiguration.getSvcConfigurationByType(PstServiceConfiguration.SERVICE_TYPE_LEAVE);                        
                    // convert periode (in minutes) to miliseconds (multiply by 60 * 1000)
                    sleepTime = (svcConf!=null ? svcConf.getPeriode():0) * 60 * 1000;                        
                    System.out.println(".:: proses generate LL's finished, thread now sleep/pause for "+svcConf.getPeriode()+" minutes ("+sleepTime+" ms)");
                    
                    System.out.println("Date start:"+Formater.formatDate(StartDate, "dd-MM-yyyy HH:mm:ss"));
                    Date tmpStartDate = new Date();
                    tmpStartDate.setHours(0);
                    tmpStartDate.setMinutes(0);
                    tmpStartDate.setSeconds(0);
              //artinya jika user menjalankan tgl 29 juni 2013 setelah berganti hari atau besoknya tgl 30 juni agar di ganti
                    StartDate = tmpStartDate;
                    Thread.sleep(sleepTime);                                            
                    System.out.println("Date perubahan:"+Formater.formatDate(StartDate, "dd-MM-yyyy HH:mm:ss"));                                                                                                     
                //}
                
            }
        } 
        catch (Exception e) 
        {
            System.out.println(">>> Exception on AutomaticStockLLUpdater service :(("+e);
              this.setRunning(false);
        }
    }
    
    /**
     * @param start
     * @param end
     * @return
     */    
    public int getSleepTime(Date start, Date end){
        Date s = new Date();
        Date e = new Date();
        
        s.setHours(start.getHours());
        s.setMinutes(start.getMinutes());
        s.setSeconds(start.getSeconds());
        
        e.setHours(end.getHours());
        e.setMinutes(end.getMinutes());
        e.setSeconds(end.getSeconds());
        
        if(end.getHours() < start.getHours())
        {
            int dtEnd = e.getDate();
            e.setDate(dtEnd+1);
        }        
        
        long st = s.getTime();
        long en = e.getTime();
        long rs = en - st;
        if(rs < 0)
        {
            rs = 0;
        }
        
        return (new Long(rs)).intValue();
    }    

    /**
     * @return the running
     */
    public boolean isRunning() {
        return running;
    }

    /**
     * @param running the running to set
     */
    public void setRunning(boolean running) {
        this.running = running;
    }

    /**
     * @return the startDate
     */
    public Date getStartDate() {
        return startDate;
    }

    /**
     * @param startDate the startDate to set
     */
    public void setStartDate(Date startDate) {
        this.startDate = startDate;
    }
    
}
